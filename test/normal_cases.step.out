(2 + 3)
5
(2 - 3)
-1
(2 * 3)
6
(2 / 3)
0
(2 <= 3)
true
(3 <= 2)
false
(2.1 + 3.1)
5.2
(2.1 - 3.1)
-1.
(2.1 * 3.1)
6.51
(4.2 / 2.1)
2.
(2.1 <= 3.1)
true
(3.1 <= 2.1)
false
(2 + 3.1)
5.1
(2.1 - 3)
-0.9
(2 * 3.1)
6.2
(2.1 / 3)
0.7
(2 <= 3.1)
true
(3.1 <= 2)
false
((2 + ((3 * 4) / 1)) <= 5)
((2 + (12 / 1)) <= 5)
((2 + 12) <= 5)
(14 <= 5)
false
true
false
(if true then 3 else 4)
3
(if (4.6 <= 3) then (if (2 <= 0.9) then 2. else 1.) else 124.9)
(if false then (if (2 <= 0.9) then 2. else 1.) else 124.9)
124.9
(if (let x : int = 5 in (x <= 10)) then 2 else 3)
(if (5 <= 10) then 2 else 3)
(if true then 2 else 3)
2
(0 / 0)
NaN
(0 / 0.)
NaN
(0. / 0)
NaN
(0. / 0.)
NaN
(4 + ((0 - 5) * 2))
(4 + (-5 * 2))
(4 + -10)
-6
(let x : int = (2 + 3) in (x <= 10))
(let x : int = 5 in (x <= 10))
(5 <= 10)
true
(let y : int = 10 in (let y : int = 1 in (y + y)))
(let y : int = 1 in (y + y))
(1 + 1)
2
(fun (x:int) : int -> ((x * 2) + 1))
((fun (y:bool) : int -> (if y then 1 else 0)) (false))
(if false then 1 else 0)
0
((fun (f:(int -> int)) : int -> (f (10))) ((fun (var:int) : int -> (var - 1))))
((fun (var:int) : int -> (var - 1)) (10))
(10 - 1)
9
(let f1 : (int -> int) = (fun (x:int) : int -> (x + 1)) in (let f2 : (int -> int) = (fun (x:int) : int -> (x - 1)) in ((f1 (5)) <= (f2 (5)))))
(let f2 : (int -> int) = (fun (x:int) : int -> (x - 1)) in (((fun (x:int) : int -> (x + 1)) (5)) <= (f2 (5))))
(((fun (x:int) : int -> (x + 1)) (5)) <= ((fun (x:int) : int -> (x - 1)) (5)))
((5 + 1) <= ((fun (x:int) : int -> (x - 1)) (5)))
(6 <= ((fun (x:int) : int -> (x - 1)) (5)))
(6 <= (5 - 1))
(6 <= 4)
false
(((fun (x:int) : (float -> float) -> (fun (y:float) : float -> (x / y))) (8)) (2.))
((fun (y:float) : float -> (8 / y)) (2.))
(8 / 2.)
4.
((fun (x:int) : (float -> float) -> (fun (y:float) : float -> (x / y))) (8))
(fun (y:float) : float -> (8 / y))
(let max2 : (int -> (int -> int)) = (fun (x:int) : (int -> int) -> (fun (y:int) : int -> (if (y <= x) then x else y))) in (let a : int = 5 in (let b : int = 2 in ((max2 (a)) (b)))))
(let a : int = 5 in (let b : int = 2 in (((fun (x:int) : (int -> int) -> (fun (y:int) : int -> (if (y <= x) then x else y))) (a)) (b))))
(let b : int = 2 in (((fun (x:int) : (int -> int) -> (fun (y:int) : int -> (if (y <= x) then x else y))) (5)) (b)))
(((fun (x:int) : (int -> int) -> (fun (y:int) : int -> (if (y <= x) then x else y))) (5)) (2))
((fun (y:int) : int -> (if (y <= 5) then 5 else y)) (2))
(if (2 <= 5) then 5 else 2)
(if true then 5 else 2)
5
(let fact : (int -> int) = (fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) in (fact (5)))
((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) (5))
(if (5 <= 0) then 1 else (5 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((5 - 1)))))
(if false then 1 else (5 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((5 - 1)))))
(5 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) (4)))
(5 * (if (4 <= 0) then 1 else (4 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((4 - 1))))))
(5 * (if false then 1 else (4 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((4 - 1))))))
(5 * (4 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) (3))))
(5 * (4 * (if (3 <= 0) then 1 else (3 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((3 - 1)))))))
(5 * (4 * (if false then 1 else (3 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((3 - 1)))))))
(5 * (4 * (3 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) (2)))))
(5 * (4 * (3 * (if (2 <= 0) then 1 else (2 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((2 - 1))))))))
(5 * (4 * (3 * (if false then 1 else (2 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((2 - 1))))))))
(5 * (4 * (3 * (2 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) (1))))))
(5 * (4 * (3 * (2 * (if (1 <= 0) then 1 else (1 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((1 - 1)))))))))
(5 * (4 * (3 * (2 * (if false then 1 else (1 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((1 - 1)))))))))
(5 * (4 * (3 * (2 * (1 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) (0)))))))
(5 * (4 * (3 * (2 * (1 * (if (0 <= 0) then 1 else (0 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((0 - 1))))))))))
(5 * (4 * (3 * (2 * (1 * (if true then 1 else (0 * ((fix f (n:int) : int -> (if (n <= 0) then 1 else (n * (f ((n - 1)))))) ((0 - 1))))))))))
(5 * (4 * (3 * (2 * (1 * 1)))))
(5 * (4 * (3 * (2 * 1))))
(5 * (4 * (3 * 2)))
(5 * (4 * 6))
(5 * 24)
120
()
(5, true)
((let x : bool = (true && (4 > 5)) in x), (fun (x:float) : float -> (x / 2.)))
((let x : bool = (true && false) in x), (fun (x:float) : float -> (x / 2.)))
((let x : bool = false in x), (fun (x:float) : float -> (x / 2.)))
(false, (fun (x:float) : float -> (x / 2.)))
(fst (5, true))
5
(snd (5, true))
true
((fst ((fun (x:int) : int -> (x + 1)), (fun (y:int) : int -> (y - 1)))) (3))
((fun (x:int) : int -> (x + 1)) (3))
(3 + 1)
4
((snd ((fun (x:int) : int -> (x + 1)), (fun (y:int) : int -> (y - 1)))) (3))
((fun (y:int) : int -> (y - 1)) (3))
(3 - 1)
2
(fun (x:bool) : (int * int) -> (if (x || (5.6 < 10)) then (0, (0 + 1)) else (9, 9)))
((fun (x:bool) : (int * int) -> (if (x || (5.6 < 10)) then (0, (0 + 1)) else (9, 9))) ((true && false)))
((fun (x:bool) : (int * int) -> (if (x || (5.6 < 10)) then (0, (0 + 1)) else (9, 9))) (false))
(if (false || (5.6 < 10)) then (0, (0 + 1)) else (9, 9))
(if (false || true) then (0, (0 + 1)) else (9, 9))
(if true then (0, (0 + 1)) else (9, 9))
(0, 1)
(hd (6 :: (5 :: [] : int)))
6
(tl (6 :: (5 :: [] : int)))
(5 :: [] : int)
(let x : int = 2 in (6 :: (x :: [] : int)))
(6 :: (2 :: [] : int))
(empty (true :: (false :: ((4 < 5) :: [] : bool))))
false
(empty [] : float)
true
(let max : (int -> ([int] -> int)) = (fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) in ((max (0)) ((4 :: (7 :: (2 :: (1 :: [] : int)))))))
(((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((4 :: (7 :: (2 :: (1 :: [] : int))))))
((fun (l:[int]) : int -> (if (empty l) then 0 else (let cur : int = (hd l) in (if (cur > 0) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((tl l))))))) ((4 :: (7 :: (2 :: (1 :: [] : int))))))
(if (empty (4 :: (7 :: (2 :: (1 :: [] : int))))) then 0 else (let cur : int = (hd (4 :: (7 :: (2 :: (1 :: [] : int))))) in (if (cur > 0) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))))))
(if false then 0 else (let cur : int = (hd (4 :: (7 :: (2 :: (1 :: [] : int))))) in (if (cur > 0) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))))))
(let cur : int = 4 in (if (cur > 0) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int)))))))))
(if (4 > 0) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))))
(if true then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (0)) ((tl (4 :: (7 :: (2 :: (1 :: [] : int))))))))
((fun (l:[int]) : int -> (if (empty l) then 4 else (let cur : int = (hd l) in (if (cur > 4) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl l))))))) ((tl (4 :: (7 :: (2 :: (1 :: [] : int)))))))
((fun (l:[int]) : int -> (if (empty l) then 4 else (let cur : int = (hd l) in (if (cur > 4) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl l))))))) ((7 :: (2 :: (1 :: [] : int)))))
(if (empty (7 :: (2 :: (1 :: [] : int)))) then 4 else (let cur : int = (hd (7 :: (2 :: (1 :: [] : int)))) in (if (cur > 4) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (7 :: (2 :: (1 :: [] : int)))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (7 :: (2 :: (1 :: [] : int)))))))))
(if false then 4 else (let cur : int = (hd (7 :: (2 :: (1 :: [] : int)))) in (if (cur > 4) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (7 :: (2 :: (1 :: [] : int)))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (7 :: (2 :: (1 :: [] : int)))))))))
(let cur : int = 7 in (if (cur > 4) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (7 :: (2 :: (1 :: [] : int)))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (7 :: (2 :: (1 :: [] : int))))))))
(if (7 > 4) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (7 :: (2 :: (1 :: [] : int)))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (7 :: (2 :: (1 :: [] : int)))))))
(if true then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (7 :: (2 :: (1 :: [] : int)))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (4)) ((tl (7 :: (2 :: (1 :: [] : int)))))))
((fun (l:[int]) : int -> (if (empty l) then 7 else (let cur : int = (hd l) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl l))))))) ((tl (7 :: (2 :: (1 :: [] : int))))))
((fun (l:[int]) : int -> (if (empty l) then 7 else (let cur : int = (hd l) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl l))))))) ((2 :: (1 :: [] : int))))
(if (empty (2 :: (1 :: [] : int))) then 7 else (let cur : int = (hd (2 :: (1 :: [] : int))) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (2 :: (1 :: [] : int))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (2 :: (1 :: [] : int))))))))
(if false then 7 else (let cur : int = (hd (2 :: (1 :: [] : int))) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (2 :: (1 :: [] : int))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (2 :: (1 :: [] : int))))))))
(let cur : int = 2 in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (2 :: (1 :: [] : int))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (2 :: (1 :: [] : int)))))))
(if (2 > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (2)) ((tl (2 :: (1 :: [] : int))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (2 :: (1 :: [] : int))))))
(if false then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (2)) ((tl (2 :: (1 :: [] : int))))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (2 :: (1 :: [] : int))))))
((fun (l:[int]) : int -> (if (empty l) then 7 else (let cur : int = (hd l) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl l))))))) ((tl (2 :: (1 :: [] : int)))))
((fun (l:[int]) : int -> (if (empty l) then 7 else (let cur : int = (hd l) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl l))))))) ((1 :: [] : int)))
(if (empty (1 :: [] : int)) then 7 else (let cur : int = (hd (1 :: [] : int)) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (1 :: [] : int)))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (1 :: [] : int)))))))
(if false then 7 else (let cur : int = (hd (1 :: [] : int)) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (1 :: [] : int)))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (1 :: [] : int)))))))
(let cur : int = 1 in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl (1 :: [] : int)))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (1 :: [] : int))))))
(if (1 > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (1)) ((tl (1 :: [] : int)))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (1 :: [] : int)))))
(if false then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (1)) ((tl (1 :: [] : int)))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl (1 :: [] : int)))))
((fun (l:[int]) : int -> (if (empty l) then 7 else (let cur : int = (hd l) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl l))))))) ((tl (1 :: [] : int))))
((fun (l:[int]) : int -> (if (empty l) then 7 else (let cur : int = (hd l) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl l))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl l))))))) ([] : int))
(if (empty [] : int) then 7 else (let cur : int = (hd [] : int) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl [] : int))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl [] : int))))))
(if true then 7 else (let cur : int = (hd [] : int) in (if (cur > 7) then (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (cur)) ((tl [] : int))) else (((fix f (cur_max:int) : ([int] -> int) -> (fun (l:[int]) : int -> (if (empty l) then cur_max else (let cur : int = (hd l) in (if (cur > cur_max) then ((f (cur)) ((tl l))) else ((f (cur_max)) ((tl l)))))))) (7)) ((tl [] : int))))))
7
(ref 6)
Ptr(0):{contents = 6}
(!(ref 3))
(!Ptr(1):{contents = 3})
3
((ref 0) := 1)
(Ptr(2):{contents = 0} := 1)
()
(let x : <int> = (ref 1) in ((!x) + 1))
(let x : <int> = Ptr(3):{contents = 1} in ((!x) + 1))
((!Ptr(3):{contents = 1}) + 1)
(1 + 1)
2
(let x : <int> = (ref 1) in ((x := 3); ((!x) + 1)))
(let x : <int> = Ptr(4):{contents = 1} in ((x := 3); ((!x) + 1)))
((Ptr(4):{contents = 1} := 3); ((!Ptr(4):{contents = 1}) + 1))
((); ((!Ptr(4):{contents = 3}) + 1))
((!Ptr(4):{contents = 3}) + 1)
(3 + 1)
4
(let x : <int> = (ref 1) in ((x := 3); ((x := ((!x) + 1)); (!x))))
(let x : <int> = Ptr(5):{contents = 1} in ((x := 3); ((x := ((!x) + 1)); (!x))))
((Ptr(5):{contents = 1} := 3); ((Ptr(5):{contents = 1} := ((!Ptr(5):{contents = 1}) + 1)); (!Ptr(5):{contents = 1})))
((); ((Ptr(5):{contents = 3} := ((!Ptr(5):{contents = 3}) + 1)); (!Ptr(5):{contents = 3})))
((Ptr(5):{contents = 3} := ((!Ptr(5):{contents = 3}) + 1)); (!Ptr(5):{contents = 3}))
((Ptr(5):{contents = 3} := (3 + 1)); (!Ptr(5):{contents = 3}))
((Ptr(5):{contents = 3} := 4); (!Ptr(5):{contents = 3}))
((); (!Ptr(5):{contents = 4}))
(!Ptr(5):{contents = 4})
4
(let x : <int> = (ref 6) in (let y : <int> = (ref 3) in ((y := ((!x) * (!y))); ((!x) + (!y)))))
(let x : <int> = Ptr(6):{contents = 6} in (let y : <int> = (ref 3) in ((y := ((!x) * (!y))); ((!x) + (!y)))))
(let y : <int> = (ref 3) in ((y := ((!Ptr(6):{contents = 6}) * (!y))); ((!Ptr(6):{contents = 6}) + (!y))))
(let y : <int> = Ptr(7):{contents = 3} in ((y := ((!Ptr(6):{contents = 6}) * (!y))); ((!Ptr(6):{contents = 6}) + (!y))))
((Ptr(7):{contents = 3} := ((!Ptr(6):{contents = 6}) * (!Ptr(7):{contents = 3}))); ((!Ptr(6):{contents = 6}) + (!Ptr(7):{contents = 3})))
((Ptr(7):{contents = 3} := (6 * (!Ptr(7):{contents = 3}))); ((!Ptr(6):{contents = 6}) + (!Ptr(7):{contents = 3})))
((Ptr(7):{contents = 3} := (6 * 3)); ((!Ptr(6):{contents = 6}) + (!Ptr(7):{contents = 3})))
((Ptr(7):{contents = 3} := 18); ((!Ptr(6):{contents = 6}) + (!Ptr(7):{contents = 3})))
((); ((!Ptr(6):{contents = 6}) + (!Ptr(7):{contents = 18})))
((!Ptr(6):{contents = 6}) + (!Ptr(7):{contents = 18}))
(6 + (!Ptr(7):{contents = 18}))
(6 + 18)
24
